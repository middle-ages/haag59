## API Report File for "commons"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Alt1 } from 'fp-ts/lib/Alt';
import { Alternative1 } from 'fp-ts/lib/Alternative';
import { applicative as AP } from 'fp-ts';
import { Apply1 } from 'fp-ts/lib/Apply';
import { Apply2C } from 'fp-ts/lib/Apply';
import { array } from 'fp-ts';
import { bifunctor as BI } from 'fp-ts';
import { BooleanAlgebra } from 'fp-ts/lib/BooleanAlgebra';
import { Bounded } from 'fp-ts/lib/Bounded';
import { Chain1 } from 'fp-ts/lib/Chain';
import { Chain2C } from 'fp-ts/lib/Chain';
import { ChainRec1 } from 'fp-ts/lib/ChainRec';
import { ChainRec2C } from 'fp-ts/lib/ChainRec';
import { Comonad2 } from 'fp-ts/lib/Comonad';
import { Compactable1 } from 'fp-ts/lib/Compactable';
import { either as EI } from 'fp-ts';
import { endomorphism as EO } from 'fp-ts';
import { eq as EQ } from 'fp-ts';
import { Extend1 } from 'fp-ts/lib/Extend';
import { Field } from 'fp-ts/lib/Field';
import { Filterable1 } from 'fp-ts/lib/Filterable';
import { FilterableWithIndex1 } from 'fp-ts/lib/FilterableWithIndex';
import { FilterE1 } from 'fp-ts/lib/Witherable';
import { Foldable1 } from 'fp-ts/lib/Foldable';
import { Foldable2 } from 'fp-ts/lib/Foldable';
import { FoldableWithIndex1 } from 'fp-ts/lib/FoldableWithIndex';
import { FromEither1 } from 'fp-ts/lib/FromEither';
import { function } from 'fp-ts';
import { Functor } from 'fp-ts/lib/Functor';
import { Functor1 } from 'fp-ts/lib/Functor';
import { Functor2 } from 'fp-ts/lib/Functor';
import { Functor2C } from 'fp-ts/lib/Functor';
import { Functor3 } from 'fp-ts/lib/Functor';
import { Functor4 } from 'fp-ts/lib/Functor';
import { FunctorWithIndex1 } from 'fp-ts/lib/FunctorWithIndex';
import { hkt as HKT } from 'fp-ts';
import { lens } from 'monocle-ts';
import { ListOf } from 'ts-toolbelt/out/Union/ListOf.js';
import { Magma } from 'fp-ts/lib/Magma';
import { monoid as MO } from 'fp-ts';
import { Monad1 } from 'fp-ts/lib/Monad';
import { Monad2 } from 'fp-ts/lib/Monad';
import { Monad2C } from 'fp-ts/lib/Monad';
import { Monad3 } from 'fp-ts/lib/Monad';
import { Monad3C } from 'fp-ts/lib/Monad';
import { Monad4 } from 'fp-ts/lib/Monad';
import { N } from 'ts-toolbelt';
import { nonEmptyArray as NEA } from 'fp-ts';
import { ord as OD } from 'fp-ts';
import { option as OP } from 'fp-ts';
import { PipeableTraverse1 } from 'fp-ts/lib/Traversable';
import { PipeableTraverse2 } from 'fp-ts/lib/Traversable';
import { PipeableTraverseWithIndex1 } from 'fp-ts/lib/TraversableWithIndex';
import { PipeableWilt1 } from 'fp-ts/lib/Witherable';
import { PipeableWither1 } from 'fp-ts/lib/Witherable';
import { Pointed1 } from 'fp-ts/lib/Pointed';
import { predicate as PRE } from 'fp-ts';
import { PredicateWithIndex } from 'fp-ts/lib/FilterableWithIndex';
import { readonlyArray as RA } from 'fp-ts';
import { record as RC } from 'fp-ts';
import { reader as RE } from 'fp-ts';
import { ReadonlyNonEmptyArray } from 'fp-ts/lib/ReadonlyNonEmptyArray';
import { Refinement } from 'fp-ts/lib/Refinement';
import { RefinementWithIndex } from 'fp-ts/lib/FilterableWithIndex';
import { Ring } from 'fp-ts/lib/Ring';
import { Semigroup } from 'fp-ts/lib/Semigroup';
import { Semigroupoid2 } from 'fp-ts/lib/Semigroupoid';
import { Semiring } from 'fp-ts/lib/Semiring';
import { Separated } from 'fp-ts/lib/Separated';
import { Sequence1 } from 'fp-ts/lib/Traversable';
import { Sequence2 } from 'fp-ts/lib/Traversable';
import { show as SH } from 'fp-ts';
import { These } from 'fp-ts/lib/These';
import { Traversable1 } from 'fp-ts/lib/Traversable';
import { Traversable2 } from 'fp-ts/lib/Traversable';
import { TraversableWithIndex1 } from 'fp-ts/lib/TraversableWithIndex';
import { U } from 'ts-toolbelt';
import { Unfoldable1 } from 'fp-ts/lib/Unfoldable';
import { Witherable1 } from 'fp-ts/lib/Witherable';
import { Zero1 } from 'fp-ts/lib/Zero';

// @public (undocumented)
export const addAfter: <T>(suffix: T[]) => Endo<T[]>;

// @public (undocumented)
export const addAround: <A>([prefix, suffix]: Pair<A[]>) => Endo<A[]>;

// @public (undocumented)
export const addBefore: <T>(prefix: T[]) => Endo<T[]>;

// @public (undocumented)
export type AdjEntry<T> = [target: T, prevNext: Pair<T[]>];

// @public (undocumented)
export type AnyTuple = readonly any[];

export { AP }

// @public (undocumented)
export const append: <T>(parent: T[]) => Unary<T, T[]>;

// @public (undocumented)
export const appendTuple: <T, TLen extends number>(fst: TupleN<T, TLen>) => <ULen extends number>(snd: TupleN<T, ULen>) => TupleN<T, N.Add<TLen, ULen>>;

// @public (undocumented)
export const apply0: <T>(fn: Lazy<T>) => T;

// @public (undocumented)
export const apply1: <A>(a: A) => <B>(fn: Unary<A, B>) => B;

// @public (undocumented)
export const applyPair: <A, B>([f, a]: [Unary<A, B>, A]) => B;

// @public (undocumented)
export const AR: {
    filterA<F extends "StateReaderTaskEither">(F: AP.Applicative4<F>): <S, R, E, A>(p: (x: A) => HKT.Kind4<F, S, R, E, boolean>) => (xs: A[]) => HKT.Kind4<F, S, R, E, A[]>;
    filterA<F_1 extends keyof HKT.URItoKind3<any, any, any>>(F: AP.Applicative3<F_1>): <R_1, E_1, A_1>(p: (x: A_1) => HKT.Kind3<F_1, R_1, E_1, boolean>) => (xs: A_1[]) => HKT.Kind3<F_1, R_1, E_1, A_1[]>;
    filterA<F_2 extends keyof HKT.URItoKind2<any, any>>(F: AP.Applicative2<F_2>): <E_2, A_2>(p: (x: A_2) => HKT.Kind2<F_2, E_2, boolean>) => (xs: A_2[]) => HKT.Kind2<F_2, E_2, A_2[]>;
    filterA<F_3 extends keyof HKT.URItoKind2<any, any>, E_3>(F: AP.Applicative2C<F_3, E_3>): <A_3>(p: (x: A_3) => HKT.Kind2<F_3, E_3, boolean>) => (xs: A_3[]) => HKT.Kind2<F_3, E_3, A_3[]>;
    filterA<F_4 extends keyof HKT.URItoKind<any>>(F: AP.Applicative1<F_4>): <A_4>(p: (x: A_4) => HKT.Kind<F_4, boolean>) => (xs: A_4[]) => HKT.Kind<F_4, A_4[]>;
    filterA<F_5>(F: AP.Applicative<F_5>): <A_5>(p: (x: A_5) => HKT.HKT<F_5, boolean>) => (xs: A_5[]) => HKT.HKT<F_5, A_5[]>;
    allM<M extends "StateReaderTaskEither">(M: Monad4<M>): <S_1, R_2, E_4>(xs: HKT.Kind4<M, S_1, R_2, E_4, boolean>[]) => HKT.Kind4<M, S_1, R_2, E_4, boolean>;
    allM<M_1 extends keyof HKT.URItoKind3<any, any, any>>(M: Monad3<M_1>): <R_3, E_5>(xs: HKT.Kind3<M_1, R_3, E_5, boolean>[]) => HKT.Kind3<M_1, R_3, E_5, boolean>;
    allM<M_2 extends keyof HKT.URItoKind3<any, any, any>, E_6>(M: Monad3C<M_2, E_6>): <R_4>(xs: HKT.Kind3<M_2, R_4, E_6, boolean>[]) => HKT.Kind3<M_2, R_4, E_6, boolean>;
    allM<M_3 extends keyof HKT.URItoKind2<any, any>>(M: Monad2<M_3>): <E_7>(xs: HKT.Kind2<M_3, E_7, boolean>[]) => HKT.Kind2<M_3, E_7, boolean>;
    allM<M_4 extends keyof HKT.URItoKind2<any, any>, E_8>(M: Monad2C<M_4, E_8>): (xs: HKT.Kind2<M_4, E_8, boolean>[]) => HKT.Kind2<M_4, E_8, boolean>;
    allM<M_5 extends keyof HKT.URItoKind<any>>(M: Monad1<M_5>): (xs: HKT.Kind<M_5, boolean>[]) => HKT.Kind<M_5, boolean>;
    anyM<M_6 extends "StateReaderTaskEither">(M: Monad4<M_6>): <S_2, R_5, E_9>(xs: HKT.Kind4<M_6, S_2, R_5, E_9, boolean>[]) => HKT.Kind4<M_6, S_2, R_5, E_9, boolean>;
    anyM<M_7 extends keyof HKT.URItoKind3<any, any, any>>(M: Monad3<M_7>): <R_6, E_10>(xs: HKT.Kind3<M_7, R_6, E_10, boolean>[]) => HKT.Kind3<M_7, R_6, E_10, boolean>;
    anyM<M_8 extends keyof HKT.URItoKind3<any, any, any>, E_11>(M: Monad3C<M_8, E_11>): <R_7>(xs: HKT.Kind3<M_8, R_7, E_11, boolean>[]) => HKT.Kind3<M_8, R_7, E_11, boolean>;
    anyM<M_9 extends keyof HKT.URItoKind2<any, any>>(M: Monad2<M_9>): <E_12>(xs: HKT.Kind2<M_9, E_12, boolean>[]) => HKT.Kind2<M_9, E_12, boolean>;
    anyM<M_10 extends keyof HKT.URItoKind2<any, any>, E_13>(M: Monad2C<M_10, E_13>): (xs: HKT.Kind2<M_10, E_13, boolean>[]) => HKT.Kind2<M_10, E_13, boolean>;
    anyM<M_11 extends keyof HKT.URItoKind<any>>(M: Monad1<M_11>): (xs: HKT.Kind<M_11, boolean>[]) => HKT.Kind<M_11, boolean>;
    elemV: <A_6>(eq: EQ.Eq<A_6>) => (xs: A_6[]) => PRE.Predicate<A_6>;
    none: <A_7>(f: PRE.Predicate<A_7>) => PRE.Predicate<A_7[]>;
    join: (x: string) => (ys: string[]) => string;
    getDisorderedEq: <A_8>(ordA: OD.Ord<A_8>) => EQ.Eq<A_8[]>;
    pluckFirst: <A_9>(p: PRE.Predicate<A_9>) => (xs: A_9[]) => [OP.Option<A_9>, A_9[]];
    upsert: <A_10>(eqA: EQ.Eq<A_10>) => (x: A_10) => (ys: A_10[]) => NEA.NonEmptyArray<A_10>;
    insertMany: (i: number) => <A_11>(xs: NEA.NonEmptyArray<A_11>) => (ys: A_11[]) => OP.Option<NEA.NonEmptyArray<A_11>>;
    dropRepeats: <A_12>(eq: EQ.Eq<A_12>) => EO.Endomorphism<A_12[]>;
    startsWith: <A_13>(eq: EQ.Eq<A_13>) => (start: A_13[]) => PRE.Predicate<A_13[]>;
    endsWith: <A_14>(eq: EQ.Eq<A_14>) => (end: A_14[]) => PRE.Predicate<A_14[]>;
    without: <A_15>(eq: EQ.Eq<A_15>) => (xs: A_15[]) => EO.Endomorphism<A_15[]>;
    cartesian: <A_16>(xs: A_16[]) => <B>(ys: B[]) => [A_16, B][];
    sum: (xs: number[]) => number;
    product: (xs: number[]) => number;
    mean: (xs: NEA.NonEmptyArray<number>) => number;
    median: (xs: NEA.NonEmptyArray<number>) => number;
    aperture: (n: number) => <A_17>(xs: A_17[]) => A_17[][];
    slice: (start: number) => (end: number) => <A_18>(xs: A_18[]) => A_18[];
    reject: <A_19>(f: PRE.Predicate<A_19>) => <B_1 extends A_19>(xs: B_1[]) => B_1[];
    moveFrom: (from: number) => (to: number) => <A_20>(xs: A_20[]) => OP.Option<A_20[]>;
    moveTo: (x: number) => (y: number) => <A_21>(xs: A_21[]) => OP.Option<A_21[]>;
    countBy: <A_22>(f: (x: A_22) => string) => (xs: A_22[]) => Record<string, number>;
    dropRightWhile: <A_23>(f: PRE.Predicate<A_23>) => <B_2 extends A_23>(xs: B_2[]) => B_2[];
    dropAt: (i: number) => (n: number) => <A_24>(xs: A_24[]) => OP.Option<A_24[]>;
    transpose: <A_25>(xs: A_25[][]) => A_25[][];
    takeRightWhile: <A_26>(f: PRE.Predicate<A_26>) => <B_3 extends A_26>(xs: B_3[]) => B_3[];
    symmetricDifference: <A_27>(eq: EQ.Eq<A_27>) => (xs: A_27[]) => EO.Endomorphism<A_27[]>;
    reduceWhile: <A_28>(p: PRE.Predicate<A_28>) => <B_4>(f: (x: A_28) => (y: B_4) => B_4) => (x: B_4) => (ys: A_28[]) => B_4;
    reduceRightWhile: <A_29>(p: PRE.Predicate<A_29>) => <B_5>(f: (x: A_29) => (y: B_5) => B_5) => (x: B_5) => (ys: A_29[]) => B_5;
    minimum: <A_30>(ord: OD.Ord<A_30>) => (xs: NEA.NonEmptyArray<A_30>) => A_30;
    maximum: <A_31>(ord: OD.Ord<A_31>) => (xs: NEA.NonEmptyArray<A_31>) => A_31;
    zipAll: <A_32>(xs: A_32[]) => <B_6>(ys: B_6[]) => These<B_6, A_32>[];
    extractAt: (i: number) => <A_33>(xs: A_33[]) => OP.Option<[A_33, A_33[]]>;
    fromIterable: <A_34>(xs: Iterable<A_34>) => A_34[];
    fromReadonly: <A_35>(xs: readonly A_35[]) => A_35[];
    toReadonly: <A_36>(xs: A_36[]) => readonly A_36[];
    fromPredicate<A_37, B_7 extends A_37>(refinement: Refinement<A_37, B_7>): (a: A_37) => B_7[];
    fromPredicate<A_38>(predicate: PRE.Predicate<A_38>): <B_8 extends A_38>(b: B_8) => B_8[];
    fromPredicate<A_39>(predicate: PRE.Predicate<A_39>): (a: A_39) => A_39[];
    takeLeftWhile<A_40, B_9 extends A_40>(refinement: Refinement<A_40, B_9>): (as: A_40[]) => B_9[];
    takeLeftWhile<A_41>(predicate: PRE.Predicate<A_41>): <B_10 extends A_41>(bs: B_10[]) => B_10[];
    takeLeftWhile<A_42>(predicate: PRE.Predicate<A_42>): (as: A_42[]) => A_42[];
    spanLeft<A_43, B_11 extends A_43>(refinement: Refinement<A_43, B_11>): (as: A_43[]) => array.Spanned<B_11, A_43>;
    spanLeft<A_44>(predicate: PRE.Predicate<A_44>): <B_12 extends A_44>(bs: B_12[]) => array.Spanned<B_12, B_12>;
    spanLeft<A_45>(predicate: PRE.Predicate<A_45>): (as: A_45[]) => array.Spanned<A_45, A_45>;
    dropLeftWhile<A_46, B_13 extends A_46>(refinement: Refinement<A_46, B_13>): (as: A_46[]) => B_13[];
    dropLeftWhile<A_47>(predicate: PRE.Predicate<A_47>): <B_14 extends A_47>(bs: B_14[]) => B_14[];
    dropLeftWhile<A_48>(predicate: PRE.Predicate<A_48>): (as: A_48[]) => A_48[];
    findFirst<A_49, B_15 extends A_49>(refinement: Refinement<A_49, B_15>): (as: A_49[]) => OP.Option<B_15>;
    findFirst<A_50>(predicate: PRE.Predicate<A_50>): <B_16 extends A_50>(bs: B_16[]) => OP.Option<B_16>;
    findFirst<A_51>(predicate: PRE.Predicate<A_51>): (as: A_51[]) => OP.Option<A_51>;
    findLast<A_52, B_17 extends A_52>(refinement: Refinement<A_52, B_17>): (as: A_52[]) => OP.Option<B_17>;
    findLast<A_53>(predicate: PRE.Predicate<A_53>): <B_18 extends A_53>(bs: B_18[]) => OP.Option<B_18>;
    findLast<A_54>(predicate: PRE.Predicate<A_54>): (as: A_54[]) => OP.Option<A_54>;
    zip<B_19>(bs: B_19[]): <A_55>(as: A_55[]) => [A_55, B_19][];
    zip<A_56, B_20>(as: A_56[], bs: B_20[]): [A_56, B_20][];
    comprehension<A_57, B_21, C, D, R_8>(input: [A_57[], B_21[], C[], D[]], f: (a: A_57, b: B_21, c: C, d: D) => R_8, g?: ((a: A_57, b: B_21, c: C, d: D) => boolean) | undefined): R_8[];
    comprehension<A_58, B_22, C_1, R_9>(input: [A_58[], B_22[], C_1[]], f: (a: A_58, b: B_22, c: C_1) => R_9, g?: ((a: A_58, b: B_22, c: C_1) => boolean) | undefined): R_9[];
    comprehension<A_59, B_23, R_10>(input: [A_59[], B_23[]], f: (a: A_59, b: B_23) => R_10, g?: ((a: A_59, b: B_23) => boolean) | undefined): R_10[];
    comprehension<A_60, R_11>(input: [A_60[]], f: (a: A_60) => R_11, g?: ((a: A_60) => boolean) | undefined): R_11[];
    union<A_61>(E: EQ.Eq<A_61>): {
        (xs: A_61[]): (ys: A_61[]) => A_61[];
        (xs: A_61[], ys: A_61[]): A_61[];
    };
    intersection<A_62>(E: EQ.Eq<A_62>): {
        (xs: A_62[]): (ys: A_62[]) => A_62[];
        (xs: A_62[], ys: A_62[]): A_62[];
    };
    difference<A_63>(E: EQ.Eq<A_63>): {
        (xs: A_63[]): (ys: A_63[]) => A_63[];
        (xs: A_63[], ys: A_63[]): A_63[];
    };
    isEmpty: <A_64>(as: A_64[]) => as is [];
    isNonEmpty: <A_65>(as: A_65[]) => as is NEA.NonEmptyArray<A_65>;
    prepend: <A_66>(head: A_66) => (tail: A_66[]) => NEA.NonEmptyArray<A_66>;
    prependW: <A_67, B_24>(head: B_24) => (tail: A_67[]) => NEA.NonEmptyArray<A_67 | B_24>;
    append: <A_68>(end: A_68) => (init: A_68[]) => NEA.NonEmptyArray<A_68>;
    appendW: <A_69, B_25>(end: B_25) => (init: A_69[]) => NEA.NonEmptyArray<A_69 | B_25>;
    makeBy: <A_70>(n: number, f: (i: number) => A_70) => A_70[];
    replicate: <A_71>(n: number, a: A_71) => A_71[];
    fromOption: <A_72>(fa: OP.Option<A_72>) => A_72[];
    fromEither: <A_73>(fa: EI.Either<unknown, A_73>) => A_73[];
    matchW: <B_26, A_74, C_2>(onEmpty: function.Lazy<B_26>, onNonEmpty: (as: NEA.NonEmptyArray<A_74>) => C_2) => (as: A_74[]) => B_26 | C_2;
    match: <B_27, A_75>(onEmpty: function.Lazy<B_27>, onNonEmpty: (as: NEA.NonEmptyArray<A_75>) => B_27) => (as: A_75[]) => B_27;
    matchLeftW: <B_28, A_76, C_3>(onEmpty: function.Lazy<B_28>, onNonEmpty: (head: A_76, tail: A_76[]) => C_3) => (as: A_76[]) => B_28 | C_3;
    matchLeft: <B_29, A_77>(onEmpty: function.Lazy<B_29>, onNonEmpty: (head: A_77, tail: A_77[]) => B_29) => (as: A_77[]) => B_29;
    foldLeft: <A_78, B_30>(onEmpty: function.Lazy<B_30>, onNonEmpty: (head: A_78, tail: A_78[]) => B_30) => (as: A_78[]) => B_30;
    matchRightW: <B_31, A_79, C_4>(onEmpty: function.Lazy<B_31>, onNonEmpty: (init: A_79[], last: A_79) => C_4) => (as: A_79[]) => B_31 | C_4;
    matchRight: <B_32, A_80>(onEmpty: function.Lazy<B_32>, onNonEmpty: (init: A_80[], last: A_80) => B_32) => (as: A_80[]) => B_32;
    foldRight: <A_81, B_33>(onEmpty: function.Lazy<B_33>, onNonEmpty: (init: A_81[], last: A_81) => B_33) => (as: A_81[]) => B_33;
    chainWithIndex: <A_82, B_34>(f: (i: number, a: A_82) => B_34[]) => (as: A_82[]) => B_34[];
    scanLeft: <A_83, B_35>(b: B_35, f: (b: B_35, a: A_83) => B_35) => (as: A_83[]) => NEA.NonEmptyArray<B_35>;
    scanRight: <A_84, B_36>(b: B_36, f: (a: A_84, b: B_36) => B_36) => (as: A_84[]) => NEA.NonEmptyArray<B_36>;
    size: <A_85>(as: A_85[]) => number;
    isOutOfBound: <A_86>(i: number, as: A_86[]) => boolean;
    lookup: {
        (i: number): <A_87>(as: A_87[]) => OP.Option<A_87>;
        <A_88>(i: number, as: A_88[]): OP.Option<A_88>;
    };
    head: <A_89>(as: A_89[]) => OP.Option<A_89>;
    last: <A_90>(as: A_90[]) => OP.Option<A_90>;
    tail: <A_91>(as: A_91[]) => OP.Option<A_91[]>;
    init: <A_92>(as: A_92[]) => OP.Option<A_92[]>;
    takeLeft: (n: number) => <A_93>(as: A_93[]) => A_93[];
    takeRight: (n: number) => <A_94>(as: A_94[]) => A_94[];
    dropLeft: (n: number) => <A_95>(as: A_95[]) => A_95[];
    dropRight: (n: number) => <A_96>(as: A_96[]) => A_96[];
    findIndex: <A_97>(predicate: PRE.Predicate<A_97>) => (as: A_97[]) => OP.Option<number>;
    findFirstMap: <A_98, B_37>(f: (a: A_98) => OP.Option<B_37>) => (as: A_98[]) => OP.Option<B_37>;
    findLastMap: <A_99, B_38>(f: (a: A_99) => OP.Option<B_38>) => (as: A_99[]) => OP.Option<B_38>;
    findLastIndex: <A_100>(predicate: PRE.Predicate<A_100>) => (as: A_100[]) => OP.Option<number>;
    copy: <A_101>(as: A_101[]) => A_101[];
    insertAt: <A_102>(i: number, a: A_102) => (as: A_102[]) => OP.Option<NEA.NonEmptyArray<A_102>>;
    updateAt: <A_103>(i: number, a: A_103) => (as: A_103[]) => OP.Option<A_103[]>;
    deleteAt: (i: number) => <A_104>(as: A_104[]) => OP.Option<A_104[]>;
    modifyAt: <A_105>(i: number, f: (a: A_105) => A_105) => (as: A_105[]) => OP.Option<A_105[]>;
    reverse: <A_106>(as: A_106[]) => A_106[];
    rights: <E_14, A_107>(as: EI.Either<E_14, A_107>[]) => A_107[];
    lefts: <E_15, A_108>(as: EI.Either<E_15, A_108>[]) => E_15[];
    sort: <B_39>(O: OD.Ord<B_39>) => <A_109 extends B_39>(as: A_109[]) => A_109[];
    zipWith: <A_110, B_40, C_5>(fa: A_110[], fb: B_40[], f: (a: A_110, b: B_40) => C_5) => C_5[];
    unzip: <A_111, B_41>(as: [A_111, B_41][]) => [A_111[], B_41[]];
    prependAll: <A_112>(middle: A_112) => (as: A_112[]) => A_112[];
    intersperse: <A_113>(middle: A_113) => (as: A_113[]) => A_113[];
    rotate: (n: number) => <A_114>(as: A_114[]) => A_114[];
    elem: <A_115>(E: EQ.Eq<A_115>) => {
        (a: A_115): (as: A_115[]) => boolean;
        (a: A_115, as: A_115[]): boolean;
    };
    uniq: <A_116>(E: EQ.Eq<A_116>) => (as: A_116[]) => A_116[];
    sortBy: <B_42>(ords: OD.Ord<B_42>[]) => <A_117 extends B_42>(as: A_117[]) => A_117[];
    chop: <A_118, B_43>(f: (as: NEA.NonEmptyArray<A_118>) => [B_43, A_118[]]) => (as: A_118[]) => B_43[];
    splitAt: (n: number) => <A_119>(as: A_119[]) => [A_119[], A_119[]];
    chunksOf: (n: number) => <A_120>(as: A_120[]) => NEA.NonEmptyArray<A_120>[];
    fromOptionK: <A_121 extends readonly unknown[], B_44>(f: (...a: A_121) => OP.Option<B_44>) => (...a: A_121) => B_44[];
    concatW: <B_45>(second: B_45[]) => <A_122>(first: A_122[]) => (B_45 | A_122)[];
    concat: <A_123>(second: A_123[]) => (first: A_123[]) => A_123[];
    of: <A_124>(a: A_124) => A_124[];
    zero: <A_125>() => A_125[];
    map: <A_126, B_46>(f: (a: A_126) => B_46) => (fa: A_126[]) => B_46[];
    ap: <A_127>(fa: A_127[]) => <B_47>(fab: ((a: A_127) => B_47)[]) => B_47[];
    chain: <A_128, B_48>(f: (a: A_128) => B_48[]) => (ma: A_128[]) => B_48[];
    flatten: <A_129>(mma: A_129[][]) => A_129[];
    mapWithIndex: <A_130, B_49>(f: (i: number, a: A_130) => B_49) => (fa: A_130[]) => B_49[];
    filterMapWithIndex: <A_131, B_50>(f: (i: number, a: A_131) => OP.Option<B_50>) => (fa: A_131[]) => B_50[];
    filterMap: <A_132, B_51>(f: (a: A_132) => OP.Option<B_51>) => (fa: A_132[]) => B_51[];
    compact: <A_133>(fa: OP.Option<A_133>[]) => A_133[];
    separate: <A_134, B_52>(fa: EI.Either<A_134, B_52>[]) => Separated<A_134[], B_52[]>;
    filter: {
        <A_135, B_53 extends A_135>(refinement: Refinement<A_135, B_53>): (as: A_135[]) => B_53[];
        <A_136>(predicate: PRE.Predicate<A_136>): <B_54 extends A_136>(bs: B_54[]) => B_54[];
        <A_137>(predicate: PRE.Predicate<A_137>): (as: A_137[]) => A_137[];
    };
    partition: {
        <A_138, B_55 extends A_138>(refinement: Refinement<A_138, B_55>): (as: A_138[]) => Separated<A_138[], B_55[]>;
        <A_139>(predicate: PRE.Predicate<A_139>): <B_56 extends A_139>(bs: B_56[]) => Separated<B_56[], B_56[]>;
        <A_140>(predicate: PRE.Predicate<A_140>): (as: A_140[]) => Separated<A_140[], A_140[]>;
    };
    partitionWithIndex: {
        <A_141, B_57 extends A_141>(refinementWithIndex: RefinementWithIndex<number, A_141, B_57>): (as: A_141[]) => Separated<A_141[], B_57[]>;
        <A_142>(predicateWithIndex: PredicateWithIndex<number, A_142>): <B_58 extends A_142>(bs: B_58[]) => Separated<B_58[], B_58[]>;
        <A_143>(predicateWithIndex: PredicateWithIndex<number, A_143>): (as: A_143[]) => Separated<A_143[], A_143[]>;
    };
    partitionMap: <A_144, B_59, C_6>(f: (a: A_144) => EI.Either<B_59, C_6>) => (fa: A_144[]) => Separated<B_59[], C_6[]>;
    partitionMapWithIndex: <A_145, B_60, C_7>(f: (i: number, a: A_145) => EI.Either<B_60, C_7>) => (fa: A_145[]) => Separated<B_60[], C_7[]>;
    altW: <B_61>(that: function.Lazy<B_61[]>) => <A_146>(fa: A_146[]) => (B_61 | A_146)[];
    alt: <A_147>(that: function.Lazy<A_147[]>) => (fa: A_147[]) => A_147[];
    filterWithIndex: {
        <A_148, B_62 extends A_148>(refinementWithIndex: RefinementWithIndex<number, A_148, B_62>): (as: A_148[]) => B_62[];
        <A_149>(predicateWithIndex: PredicateWithIndex<number, A_149>): <B_63 extends A_149>(bs: B_63[]) => B_63[];
        <A_150>(predicateWithIndex: PredicateWithIndex<number, A_150>): (as: A_150[]) => A_150[];
    };
    extend: <A_151, B_64>(f: (as: A_151[]) => B_64) => (as: A_151[]) => B_64[];
    duplicate: <A_152>(wa: A_152[]) => A_152[][];
    foldMap: <M_12>(M: MO.Monoid<M_12>) => <A_153>(f: (a: A_153) => M_12) => (fa: A_153[]) => M_12;
    foldMapWithIndex: <M_13>(M: MO.Monoid<M_13>) => <A_154>(f: (i: number, a: A_154) => M_13) => (fa: A_154[]) => M_13;
    reduce: <A_155, B_65>(b: B_65, f: (b: B_65, a: A_155) => B_65) => (fa: A_155[]) => B_65;
    reduceWithIndex: <A_156, B_66>(b: B_66, f: (i: number, b: B_66, a: A_156) => B_66) => (fa: A_156[]) => B_66;
    reduceRight: <A_157, B_67>(b: B_67, f: (a: A_157, b: B_67) => B_67) => (fa: A_157[]) => B_67;
    reduceRightWithIndex: <A_158, B_68>(b: B_68, f: (i: number, a: A_158, b: B_68) => B_68) => (fa: A_158[]) => B_68;
    traverse: PipeableTraverse1<"Array">;
    sequence: Sequence1<"Array">;
    traverseWithIndex: PipeableTraverseWithIndex1<"Array", number>;
    wither: PipeableWither1<"Array">;
    wilt: PipeableWilt1<"Array">;
    unfold: <A_159, B_69>(b: B_69, f: (b: B_69) => OP.Option<readonly [A_159, B_69]>) => A_159[];
    URI: "Array";
    getShow: <A_160>(S: SH.Show<A_160>) => SH.Show<A_160[]>;
    getSemigroup: <A_161 = never>() => Semigroup<A_161[]>;
    getMonoid: <A_162 = never>() => MO.Monoid<A_162[]>;
    getEq: <A_163>(E: EQ.Eq<A_163>) => EQ.Eq<A_163[]>;
    getOrd: <A_164>(O: OD.Ord<A_164>) => OD.Ord<A_164[]>;
    getUnionSemigroup: <A_165>(E: EQ.Eq<A_165>) => Semigroup<A_165[]>;
    getUnionMonoid: <A_166>(E: EQ.Eq<A_166>) => MO.Monoid<A_166[]>;
    getIntersectionSemigroup: <A_167>(E: EQ.Eq<A_167>) => Semigroup<A_167[]>;
    getDifferenceMagma: <A_168>(E: EQ.Eq<A_168>) => Magma<A_168[]>;
    Functor: Functor1<"Array">;
    flap: <A_169>(a: A_169) => <B_70>(fab: ((a: A_169) => B_70)[]) => B_70[];
    Pointed: Pointed1<"Array">;
    FunctorWithIndex: FunctorWithIndex1<"Array", number>;
    Apply: Apply1<"Array">;
    apFirst: <B_71>(second: B_71[]) => <A_170>(first: A_170[]) => A_170[];
    apSecond: <B_72>(second: B_72[]) => <A_171>(first: A_171[]) => B_72[];
    Applicative: AP.Applicative1<"Array">;
    Chain: Chain1<"Array">;
    chainFirst: <A_172, B_73>(f: (a: A_172) => B_73[]) => (first: A_172[]) => A_172[];
    Monad: Monad1<"Array">;
    Unfoldable: Unfoldable1<"Array">;
    Alt: Alt1<"Array">;
    Zero: Zero1<"Array">;
    guard: (b: boolean) => void[];
    Alternative: Alternative1<"Array">;
    Extend: Extend1<"Array">;
    Compactable: Compactable1<"Array">;
    Filterable: Filterable1<"Array">;
    FilterableWithIndex: FilterableWithIndex1<"Array", number>;
    Foldable: Foldable1<"Array">;
    FoldableWithIndex: FoldableWithIndex1<"Array", number>;
    Traversable: Traversable1<"Array">;
    TraversableWithIndex: TraversableWithIndex1<"Array", number>;
    Witherable: Witherable1<"Array">;
    chainRecDepthFirst: <A_173, B_74>(f: (a: A_173) => EI.Either<A_173, B_74>[]) => (a: A_173) => B_74[];
    ChainRecDepthFirst: ChainRec1<"Array">;
    chainRecBreadthFirst: <A_174, B_75>(f: (a: A_174) => EI.Either<A_174, B_75>[]) => (a: A_174) => B_75[];
    ChainRecBreadthFirst: ChainRec1<"Array">;
    filterE: FilterE1<"Array">;
    FromEither: FromEither1<"Array">;
    fromEitherK: <E_16, A_175 extends readonly unknown[], B_76>(f: (...a: A_175) => EI.Either<E_16, B_76>) => (...a: A_175) => B_76[];
    unsafeInsertAt: <A_176>(i: number, a: A_176, as: A_176[]) => NEA.NonEmptyArray<A_176>;
    unsafeUpdateAt: <A_177>(i: number, a: A_177, as: A_177[]) => A_177[];
    unsafeDeleteAt: <A_178>(i: number, as: A_178[]) => A_178[];
    every: {
        <A_179, B_77 extends A_179>(refinement: Refinement<A_179, B_77>): Refinement<A_179[], B_77[]>;
        <A_180>(predicate: PRE.Predicate<A_180>): PRE.Predicate<A_180[]>;
    };
    some: <A_181>(predicate: PRE.Predicate<A_181>) => (as: A_181[]) => as is NEA.NonEmptyArray<A_181>;
    exists: <A_182>(predicate: PRE.Predicate<A_182>) => (as: A_182[]) => as is NEA.NonEmptyArray<A_182>;
    intercalate: <A_183>(M: MO.Monoid<A_183>) => (middle: A_183) => (as: A_183[]) => A_183;
    Do: {}[];
    bindTo: <N extends string>(name: N) => <A_184>(fa: A_184[]) => { readonly [K in N]: A_184; }[];
    let: <N_1 extends string, A_185, B_78>(name: Exclude<N_1, keyof A_185>, f: (a: A_185) => B_78) => (fa: A_185[]) => { readonly [K_1 in N_1 | keyof A_185]: K_1 extends keyof A_185 ? A_185[K_1] : B_78; }[];
    bind: <N_2 extends string, A_186, B_79>(name: Exclude<N_2, keyof A_186>, f: (a: A_186) => B_79[]) => (ma: A_186[]) => { readonly [K_2 in N_2 | keyof A_186]: K_2 extends keyof A_186 ? A_186[K_2] : B_79; }[];
    apS: <N_3 extends string, A_187, B_80>(name: Exclude<N_3, keyof A_187>, fb: B_80[]) => (fa: A_187[]) => { readonly [K_3 in N_3 | keyof A_187]: K_3 extends keyof A_187 ? A_187[K_3] : B_80; }[];
    range: (start: number, end: number) => NEA.NonEmptyArray<number>;
    empty: never[];
    cons: typeof NEA.cons;
    snoc: <A_188>(init: A_188[], end: A_188) => NEA.NonEmptyArray<A_188>;
    prependToAll: <A_189>(middle: A_189) => (as: A_189[]) => A_189[];
    array: FunctorWithIndex1<"Array", number> & Monad1<"Array"> & Unfoldable1<"Array"> & Alternative1<"Array"> & Extend1<"Array"> & FilterableWithIndex1<"Array", number> & FoldableWithIndex1<"Array", number> & TraversableWithIndex1<"Array", number> & Witherable1<"Array">;
};

// @public (undocumented)
export const around: Binary<string, string, Endo<string>>;

export { BI }

// @public (undocumented)
export type Binary<P, Q, R> = FunctionN<[P, Q], R>;

// @public (undocumented)
export type BinaryC<P, Q, R> = Unary<P, Unary<Q, R>>;

// @public (undocumented)
export type BinOp<P> = Binary<P, P, P>;

// @public (undocumented)
export type BinOpC<P> = BinaryC<P, P, P>;

// @public (undocumented)
export type BinOpT<P> = Unary<[P, P], P>;

// @public (undocumented)
export type ByteArray = Uint8ClampedArray;

// @public (undocumented)
export const ByteArray: Uint8ClampedArrayConstructor;

// @public
export const callWith: <A, B>(f: Unary<A, Unary<A, B>>) => Unary<A, B>;

// @public (undocumented)
export const ceilMod: Endo<Pair<number>>;

// @public
export const chunk4x: <T>(rows: T[][]) => Pair<Pair<OP.Option<T>>>[][];

// @public (undocumented)
export const chunksOf: (n: number) => <T>(ts: T[]) => T[][];

// @public
export const copyFromLensWith: <R>(f: Endo<R>) => <T>([fromLens, toLens]: Pair<lens.Lens<T, R>>) => Unary<Pair<T>, T>;

// @public (undocumented)
export type curry2F = <A, B, C>(f: Binary<A, B, C>) => BinaryC<B, A, C>;

// @public
export const curry2F: curry2F;

// @public (undocumented)
export const delayResult: <T>(thunk: Lazy<Trampoline<T>>) => Trampoline<T>;

// @public (undocumented)
export type DropLast<T extends AnyTuple> = T extends readonly [...infer L, any] ? L : [];

// @public (undocumented)
export type Effect<T> = Unary<T, void>;

export { EI }

// @public (undocumented)
export const emptyByteArray: Unary<number, ByteArray>;

// @public (undocumented)
export type Endo<T> = EO.Endomorphism<T>;

// @public (undocumented)
export type EndoOf<T> = <U extends T>(src: U) => U;

// @public (undocumented)
export type EntryToRecord<T extends readonly [PropertyKey, any]> = T extends T ? Record<T[0], T[1]> : never;

export { EO }

export { EQ }

// @public (undocumented)
export type Extract2<F extends HKT.URIS2, B> = <E, A>(from: HKT.Kind2<F, E, A>) => B;

// @public (undocumented)
type Extract_2<F extends HKT.URIS, B> = <A>(from: HKT.Kind<F, A>) => B;
export { Extract_2 as Extract }

// @public (undocumented)
export const finalResult: <T>(value: T) => Trampoline<T>;

// @public (undocumented)
export type Flatten<T> = {} & {
    [P in keyof T]: T[P];
};

// @public (undocumented)
export const flattenPair: <T>([fst, snd]: Pair<Pair<T>>) => Tuple4<T>;

// @public (undocumented)
export const floorMod: Endo<Pair<number>>;

// @public (undocumented)
export const flowPair: <A, B, C>([f, g]: [Unary<B, C>, Unary<A, B>]) => Unary<A, C>;

// @public (undocumented)
export const FN: {
    fork<A, B, C>(fs: [(x: A) => B, (x: A) => C]): (x: A) => [B, C];
    fork<A_1, B_1, C_1, D>(fs: [(x: A_1) => B_1, (x: A_1) => C_1, (x: A_1) => D]): (x: A_1) => [B_1, C_1, D];
    fork<A_2, B_2, C_2, D_1, E>(fs: [(x: A_2) => B_2, (x: A_2) => C_2, (x: A_2) => D_1, (x: A_2) => E]): (x: A_2) => [B_2, C_2, D_1, E];
    fork<A_3, B_3, C_3, D_2, E_1, F>(fs: [(x: A_3) => B_3, (x: A_3) => C_3, (x: A_3) => D_2, (x: A_3) => E_1, (x: A_3) => F]): (x: A_3) => [B_3, C_3, D_2, E_1, F];
    fork<A_4, B_4, C_4, D_3, E_2, F_1, G>(fs: [(x: A_4) => B_4, (x: A_4) => C_4, (x: A_4) => D_3, (x: A_4) => E_2, (x: A_4) => F_1, (x: A_4) => G]): (x: A_4) => [B_4, C_4, D_3, E_2, F_1, G];
    fork<A_5, B_5, C_5, D_4, E_3, F_2, G_1, H>(fs: [(x: A_5) => B_5, (x: A_5) => C_5, (x: A_5) => D_4, (x: A_5) => E_3, (x: A_5) => F_2, (x: A_5) => G_1, (x: A_5) => H]): (x: A_5) => [B_5, C_5, D_4, E_3, F_2, G_1, H];
    fork<A_6, B_6, C_6, D_5, E_4, F_3, G_2, H_1, I>(fs: [(x: A_6) => B_6, (x: A_6) => C_6, (x: A_6) => D_5, (x: A_6) => E_4, (x: A_6) => F_3, (x: A_6) => G_2, (x: A_6) => H_1, (x: A_6) => I]): (x: A_6) => [B_6, C_6, D_5, E_4, F_3, G_2, H_1, I];
    fork<A_7, B_7, C_7, D_6, E_5, F_4, G_3, H_2, I_1, J>(fs: [(x: A_7) => B_7, (x: A_7) => C_7, (x: A_7) => D_6, (x: A_7) => E_5, (x: A_7) => F_4, (x: A_7) => G_3, (x: A_7) => H_2, (x: A_7) => I_1, (x: A_7) => J]): (x: A_7) => [B_7, C_7, D_6, E_5, F_4, G_3, H_2, I_1, J];
    URI: "Function";
    map: <B_8, C_8>(f: (x: B_8) => C_8) => <A_8>(g: (x: A_8) => B_8) => (x: A_8) => C_8;
    Functor: Functor2<"Function">;
    of: <A_9>(x: A_9) => <B_9>(y: B_9) => A_9;
    ap: <A_10, B_10>(f: (x: A_10) => B_10) => <C_9>(g: (x: A_10) => (y: B_10) => C_9) => (x: A_10) => C_9;
    Applicative: AP.Applicative2<"Function">;
    chain: <A_11, B_11, C_10>(f: (x: B_11) => (y: A_11) => C_10) => (g: (x: A_11) => B_11) => (x: A_11) => C_10;
    Monad: Monad2<"Function">;
    flip: <A_12, B_12, C_11>(f: (x: A_12) => (y: B_12) => C_11) => (x: B_12) => (y: A_12) => C_11;
    withIndex: <A_13, B_13, C_12>(f: (g: (x: A_13) => B_13) => (ys: A_13[]) => C_12[]) => (g: (i: number) => (x: A_13) => B_13) => (ys: A_13[]) => C_12[];
    unary: <A_14 extends unknown[], B_14>(f: (...xs: A_14) => B_14) => (xs: A_14) => B_14;
    guard: <A_15, B_15>(branches: [PRE.Predicate<A_15>, (x: A_15) => B_15][]) => (fallback: (x: A_15) => B_15) => (input: A_15) => B_15;
    ifElse: <A_16, B_16>(onTrue: (x: A_16) => B_16) => (onFalse: (x: A_16) => B_16) => (f: PRE.Predicate<A_16>) => (x: A_16) => B_16;
    unless: <A_17>(f: PRE.Predicate<A_17>) => (onFalse: EO.Endomorphism<A_17>) => EO.Endomorphism<A_17>;
    when: <A_18>(f: PRE.Predicate<A_18>) => (onTrue: EO.Endomorphism<A_18>) => EO.Endomorphism<A_18>;
    until: <A_19>(f: PRE.Predicate<A_19>) => (g: EO.Endomorphism<A_19>) => EO.Endomorphism<A_19>;
    construct: <A_20 extends unknown[], B_17>(x: new (...xs: A_20) => B_17) => (xs: A_20) => B_17;
    invoke: <A_21 extends string>(x: A_21) => <B_18 extends unknown[]>(ys: [...B_18]) => <C_13>(z: Record<A_21, (...xs: B_18) => C_13>) => C_13;
    invokeNullary: <A_22 extends string>(x: A_22) => <B_19>(y: Record<A_22, () => B_19>) => B_19;
    invokeOn: <A_23>() => <B_20 extends { [K in keyof A_23]: A_23[K] extends (...xs: any[]) => unknown ? A_23[K] : never; }, C_14 extends keyof B_20>(x: C_14) => (xs: Required<Parameters<B_20[C_14]>>) => (y: B_20) => ReturnType<B_20[C_14]>;
    memoize: <A_24>(eq: EQ.Eq<A_24>) => <B_21>(f: (x: A_24) => B_21) => (x: A_24) => B_21;
    curry2T: <A_25, B_22, C_15>(f: (xs: [A_25, B_22]) => C_15) => (a: A_25) => (b: B_22) => C_15;
    curry2: <A_26, B_23, C_16>(f: (a: A_26, b: B_23) => C_16) => (a: A_26) => (b: B_23) => C_16;
    curry3T: <A_27, B_24, C_17, D_7>(f: (xs: [A_27, B_24, C_17]) => D_7) => (a: A_27) => (b: B_24) => (c: C_17) => D_7;
    curry3: <A_28, B_25, C_18, D_8>(f: (a: A_28, b: B_25, c: C_18) => D_8) => (a: A_28) => (b: B_25) => (c: C_18) => D_8;
    curry4T: <A_29, B_26, C_19, D_9, E_6>(f: (xs: [A_29, B_26, C_19, D_9]) => E_6) => (a: A_29) => (b: B_26) => (c: C_19) => (d: D_9) => E_6;
    curry4: <A_30, B_27, C_20, D_10, E_7>(f: (a: A_30, b: B_27, c: C_20, d: D_10) => E_7) => (a: A_30) => (b: B_27) => (c: C_20) => (d: D_10) => E_7;
    curry5T: <A_31, B_28, C_21, D_11, E_8, F_5>(f: (xs: [A_31, B_28, C_21, D_11, E_8]) => F_5) => (a: A_31) => (b: B_28) => (c: C_21) => (d: D_11) => (e: E_8) => F_5;
    curry5: <A_32, B_29, C_22, D_12, E_9, F_6>(f: (a: A_32, b: B_29, c: C_22, d: D_12, e: E_9) => F_6) => (a: A_32) => (b: B_29) => (c: C_22) => (d: D_12) => (e: E_9) => F_6;
    uncurry2: <A_33, B_30, C_23>(f: (a: A_33) => (b: B_30) => C_23) => ([a, b]: [A_33, B_30]) => C_23;
    uncurry3: <A_34, B_31, C_24, D_13>(f: (a: A_34) => (b: B_31) => (c: C_24) => D_13) => ([a, b, c]: [A_34, B_31, C_24]) => D_13;
    uncurry4: <A_35, B_32, C_25, D_14, E_10>(f: (a: A_35) => (b: B_32) => (c: C_25) => (d: D_14) => E_10) => ([a, b, c, d]: [A_35, B_32, C_25, D_14]) => E_10;
    uncurry5: <A_36, B_33, C_26, D_15, E_11, F_7>(f: (a: A_36) => (b: B_33) => (c: C_26) => (d: D_15) => (e: E_11) => F_7) => ([a, b, c, d, e]: [A_36, B_33, C_26, D_15, E_11]) => F_7;
    converge: <B_34, C_27 extends B_34[], D_16>(f: (xs: [B_34, ...C_27]) => D_16) => <A_37>(gs: [(x: A_37) => B_34, ...{ [K_1 in keyof C_27]: (x: A_37) => C_27[K_1]; }]) => (x: A_37) => D_16;
    is: <A_38>(x: new (...args: any[]) => unknown) => Refinement<unknown, A_38>;
    applyEvery: <A_39>(fs: EO.Endomorphism<A_39>[]) => EO.Endomorphism<A_39>;
    applySomes: <A_40>(fs: OP.Option<EO.Endomorphism<A_40>>[]) => EO.Endomorphism<A_40>;
    identity<A_41>(a: A_41): A_41;
    constant<A_42>(a: A_42): function.Lazy<A_42>;
    flow<A_43 extends readonly unknown[], B_35>(ab: (...a: A_43) => B_35): (...a: A_43) => B_35;
    flow<A_44 extends readonly unknown[], B_36, C_28>(ab: (...a: A_44) => B_36, bc: (b: B_36) => C_28): (...a: A_44) => C_28;
    flow<A_45 extends readonly unknown[], B_37, C_29, D_17>(ab: (...a: A_45) => B_37, bc: (b: B_37) => C_29, cd: (c: C_29) => D_17): (...a: A_45) => D_17;
    flow<A_46 extends readonly unknown[], B_38, C_30, D_18, E_12>(ab: (...a: A_46) => B_38, bc: (b: B_38) => C_30, cd: (c: C_30) => D_18, de: (d: D_18) => E_12): (...a: A_46) => E_12;
    flow<A_47 extends readonly unknown[], B_39, C_31, D_19, E_13, F_8>(ab: (...a: A_47) => B_39, bc: (b: B_39) => C_31, cd: (c: C_31) => D_19, de: (d: D_19) => E_13, ef: (e: E_13) => F_8): (...a: A_47) => F_8;
    flow<A_48 extends readonly unknown[], B_40, C_32, D_20, E_14, F_9, G_4>(ab: (...a: A_48) => B_40, bc: (b: B_40) => C_32, cd: (c: C_32) => D_20, de: (d: D_20) => E_14, ef: (e: E_14) => F_9, fg: (f: F_9) => G_4): (...a: A_48) => G_4;
    flow<A_49 extends readonly unknown[], B_41, C_33, D_21, E_15, F_10, G_5, H_3>(ab: (...a: A_49) => B_41, bc: (b: B_41) => C_33, cd: (c: C_33) => D_21, de: (d: D_21) => E_15, ef: (e: E_15) => F_10, fg: (f: F_10) => G_5, gh: (g: G_5) => H_3): (...a: A_49) => H_3;
    flow<A_50 extends readonly unknown[], B_42, C_34, D_22, E_16, F_11, G_6, H_4, I_2>(ab: (...a: A_50) => B_42, bc: (b: B_42) => C_34, cd: (c: C_34) => D_22, de: (d: D_22) => E_16, ef: (e: E_16) => F_11, fg: (f: F_11) => G_6, gh: (g: G_6) => H_4, hi: (h: H_4) => I_2): (...a: A_50) => I_2;
    flow<A_51 extends readonly unknown[], B_43, C_35, D_23, E_17, F_12, G_7, H_5, I_3, J_1>(ab: (...a: A_51) => B_43, bc: (b: B_43) => C_35, cd: (c: C_35) => D_23, de: (d: D_23) => E_17, ef: (e: E_17) => F_12, fg: (f: F_12) => G_7, gh: (g: G_7) => H_5, hi: (h: H_5) => I_3, ij: (i: I_3) => J_1): (...a: A_51) => J_1;
    tuple<T extends readonly any[]>(...t: T): T;
    increment(n: number): number;
    decrement(n: number): number;
    absurd<A_52>(_: never): A_52;
    tupled<A_53 extends readonly unknown[], B_44>(f: (...a: A_53) => B_44): (a: A_53) => B_44;
    untupled<A_54 extends readonly unknown[], B_45>(f: (a: A_54) => B_45): (...a: A_54) => B_45;
    pipe<A_55>(a: A_55): A_55;
    pipe<A_56, B_46>(a: A_56, ab: (a: A_56) => B_46): B_46;
    pipe<A_57, B_47, C_36>(a: A_57, ab: (a: A_57) => B_47, bc: (b: B_47) => C_36): C_36;
    pipe<A_58, B_48, C_37, D_24>(a: A_58, ab: (a: A_58) => B_48, bc: (b: B_48) => C_37, cd: (c: C_37) => D_24): D_24;
    pipe<A_59, B_49, C_38, D_25, E_18>(a: A_59, ab: (a: A_59) => B_49, bc: (b: B_49) => C_38, cd: (c: C_38) => D_25, de: (d: D_25) => E_18): E_18;
    pipe<A_60, B_50, C_39, D_26, E_19, F_13>(a: A_60, ab: (a: A_60) => B_50, bc: (b: B_50) => C_39, cd: (c: C_39) => D_26, de: (d: D_26) => E_19, ef: (e: E_19) => F_13): F_13;
    pipe<A_61, B_51, C_40, D_27, E_20, F_14, G_8>(a: A_61, ab: (a: A_61) => B_51, bc: (b: B_51) => C_40, cd: (c: C_40) => D_27, de: (d: D_27) => E_20, ef: (e: E_20) => F_14, fg: (f: F_14) => G_8): G_8;
    pipe<A_62, B_52, C_41, D_28, E_21, F_15, G_9, H_6>(a: A_62, ab: (a: A_62) => B_52, bc: (b: B_52) => C_41, cd: (c: C_41) => D_28, de: (d: D_28) => E_21, ef: (e: E_21) => F_15, fg: (f: F_15) => G_9, gh: (g: G_9) => H_6): H_6;
    pipe<A_63, B_53, C_42, D_29, E_22, F_16, G_10, H_7, I_4>(a: A_63, ab: (a: A_63) => B_53, bc: (b: B_53) => C_42, cd: (c: C_42) => D_29, de: (d: D_29) => E_22, ef: (e: E_22) => F_16, fg: (f: F_16) => G_10, gh: (g: G_10) => H_7, hi: (h: H_7) => I_4): I_4;
    pipe<A_64, B_54, C_43, D_30, E_23, F_17, G_11, H_8, I_5, J_2>(a: A_64, ab: (a: A_64) => B_54, bc: (b: B_54) => C_43, cd: (c: C_43) => D_30, de: (d: D_30) => E_23, ef: (e: E_23) => F_17, fg: (f: F_17) => G_11, gh: (g: G_11) => H_8, hi: (h: H_8) => I_5, ij: (i: I_5) => J_2): J_2;
    pipe<A_65, B_55, C_44, D_31, E_24, F_18, G_12, H_9, I_6, J_3, K_2>(a: A_65, ab: (a: A_65) => B_55, bc: (b: B_55) => C_44, cd: (c: C_44) => D_31, de: (d: D_31) => E_24, ef: (e: E_24) => F_18, fg: (f: F_18) => G_12, gh: (g: G_12) => H_9, hi: (h: H_9) => I_6, ij: (i: I_6) => J_3, jk: (j: J_3) => K_2): K_2;
    pipe<A_66, B_56, C_45, D_32, E_25, F_19, G_13, H_10, I_7, J_4, K_3, L>(a: A_66, ab: (a: A_66) => B_56, bc: (b: B_56) => C_45, cd: (c: C_45) => D_32, de: (d: D_32) => E_25, ef: (e: E_25) => F_19, fg: (f: F_19) => G_13, gh: (g: G_13) => H_10, hi: (h: H_10) => I_7, ij: (i: I_7) => J_4, jk: (j: J_4) => K_3, kl: (k: K_3) => L): L;
    pipe<A_67, B_57, C_46, D_33, E_26, F_20, G_14, H_11, I_8, J_5, K_4, L_1, M>(a: A_67, ab: (a: A_67) => B_57, bc: (b: B_57) => C_46, cd: (c: C_46) => D_33, de: (d: D_33) => E_26, ef: (e: E_26) => F_20, fg: (f: F_20) => G_14, gh: (g: G_14) => H_11, hi: (h: H_11) => I_8, ij: (i: I_8) => J_5, jk: (j: J_5) => K_4, kl: (k: K_4) => L_1, lm: (l: L_1) => M): M;
    pipe<A_68, B_58, C_47, D_34, E_27, F_21, G_15, H_12, I_9, J_6, K_5, L_2, M_1, N>(a: A_68, ab: (a: A_68) => B_58, bc: (b: B_58) => C_47, cd: (c: C_47) => D_34, de: (d: D_34) => E_27, ef: (e: E_27) => F_21, fg: (f: F_21) => G_15, gh: (g: G_15) => H_12, hi: (h: H_12) => I_9, ij: (i: I_9) => J_6, jk: (j: J_6) => K_5, kl: (k: K_5) => L_2, lm: (l: L_2) => M_1, mn: (m: M_1) => N): N;
    pipe<A_69, B_59, C_48, D_35, E_28, F_22, G_16, H_13, I_10, J_7, K_6, L_3, M_2, N_1, O>(a: A_69, ab: (a: A_69) => B_59, bc: (b: B_59) => C_48, cd: (c: C_48) => D_35, de: (d: D_35) => E_28, ef: (e: E_28) => F_22, fg: (f: F_22) => G_16, gh: (g: G_16) => H_13, hi: (h: H_13) => I_10, ij: (i: I_10) => J_7, jk: (j: J_7) => K_6, kl: (k: K_6) => L_3, lm: (l: L_3) => M_2, mn: (m: M_2) => N_1, no: (n: N_1) => O): O;
    pipe<A_70, B_60, C_49, D_36, E_29, F_23, G_17, H_14, I_11, J_8, K_7, L_4, M_3, N_2, O_1, P>(a: A_70, ab: (a: A_70) => B_60, bc: (b: B_60) => C_49, cd: (c: C_49) => D_36, de: (d: D_36) => E_29, ef: (e: E_29) => F_23, fg: (f: F_23) => G_17, gh: (g: G_17) => H_14, hi: (h: H_14) => I_11, ij: (i: I_11) => J_8, jk: (j: J_8) => K_7, kl: (k: K_7) => L_4, lm: (l: L_4) => M_3, mn: (m: M_3) => N_2, no: (n: N_2) => O_1, op: (o: O_1) => P): P;
    pipe<A_71, B_61, C_50, D_37, E_30, F_24, G_18, H_15, I_12, J_9, K_8, L_5, M_4, N_3, O_2, P_1, Q>(a: A_71, ab: (a: A_71) => B_61, bc: (b: B_61) => C_50, cd: (c: C_50) => D_37, de: (d: D_37) => E_30, ef: (e: E_30) => F_24, fg: (f: F_24) => G_18, gh: (g: G_18) => H_15, hi: (h: H_15) => I_12, ij: (i: I_12) => J_9, jk: (j: J_9) => K_8, kl: (k: K_8) => L_5, lm: (l: L_5) => M_4, mn: (m: M_4) => N_3, no: (n: N_3) => O_2, op: (o: O_2) => P_1, pq: (p: P_1) => Q): Q;
    pipe<A_72, B_62, C_51, D_38, E_31, F_25, G_19, H_16, I_13, J_10, K_9, L_6, M_5, N_4, O_3, P_2, Q_1, R>(a: A_72, ab: (a: A_72) => B_62, bc: (b: B_62) => C_51, cd: (c: C_51) => D_38, de: (d: D_38) => E_31, ef: (e: E_31) => F_25, fg: (f: F_25) => G_19, gh: (g: G_19) => H_16, hi: (h: H_16) => I_13, ij: (i: I_13) => J_10, jk: (j: J_10) => K_9, kl: (k: K_9) => L_6, lm: (l: L_6) => M_5, mn: (m: M_5) => N_4, no: (n: N_4) => O_3, op: (o: O_3) => P_2, pq: (p: P_2) => Q_1, qr: (q: Q_1) => R): R;
    pipe<A_73, B_63, C_52, D_39, E_32, F_26, G_20, H_17, I_14, J_11, K_10, L_7, M_6, N_5, O_4, P_3, Q_2, R_1, S>(a: A_73, ab: (a: A_73) => B_63, bc: (b: B_63) => C_52, cd: (c: C_52) => D_39, de: (d: D_39) => E_32, ef: (e: E_32) => F_26, fg: (f: F_26) => G_20, gh: (g: G_20) => H_17, hi: (h: H_17) => I_14, ij: (i: I_14) => J_11, jk: (j: J_11) => K_10, kl: (k: K_10) => L_7, lm: (l: L_7) => M_6, mn: (m: M_6) => N_5, no: (n: N_5) => O_4, op: (o: O_4) => P_3, pq: (p: P_3) => Q_2, qr: (q: Q_2) => R_1, rs: (r: R_1) => S): S;
    pipe<A_74, B_64, C_53, D_40, E_33, F_27, G_21, H_18, I_15, J_12, K_11, L_8, M_7, N_6, O_5, P_4, Q_3, R_2, S_1, T_1>(a: A_74, ab: (a: A_74) => B_64, bc: (b: B_64) => C_53, cd: (c: C_53) => D_40, de: (d: D_40) => E_33, ef: (e: E_33) => F_27, fg: (f: F_27) => G_21, gh: (g: G_21) => H_18, hi: (h: H_18) => I_15, ij: (i: I_15) => J_12, jk: (j: J_12) => K_11, kl: (k: K_11) => L_8, lm: (l: L_8) => M_7, mn: (m: M_7) => N_6, no: (n: N_6) => O_5, op: (o: O_5) => P_4, pq: (p: P_4) => Q_3, qr: (q: Q_3) => R_2, rs: (r: R_2) => S_1, st: (s: S_1) => T_1): T_1;
    not<A_75>(predicate: function.Predicate<A_75>): function.Predicate<A_75>;
    getBooleanAlgebra: <B_65>(B: BooleanAlgebra<B_65>) => <A_76 = never>() => BooleanAlgebra<(a: A_76) => B_65>;
    getSemigroup: <S_2>(S: Semigroup<S_2>) => <A_77 = never>() => Semigroup<(a: A_77) => S_2>;
    getMonoid: <M_8>(M: MO.Monoid<M_8>) => <A_78 = never>() => MO.Monoid<(a: A_78) => M_8>;
    getSemiring: <A_79, B_66>(S: Semiring<B_66>) => Semiring<(a: A_79) => B_66>;
    getRing: <A_80, B_67>(R: Ring<B_67>) => Ring<(a: A_80) => B_67>;
    apply: <A_81>(a: A_81) => <B_68>(f: (a: A_81) => B_68) => B_68;
    unsafeCoerce: <A_82, B_69>(a: A_82) => B_69;
    constTrue: function.Lazy<boolean>;
    constFalse: function.Lazy<boolean>;
    constNull: function.Lazy<null>;
    constUndefined: function.Lazy<undefined>;
    constVoid: function.Lazy<void>;
    hole: <T_2>() => T_2;
    SK: <A_83, B_70>(_: A_83, b: B_70) => B_70;
    getEndomorphismMonoid: <A_84 = never>() => MO.Monoid<function.Endomorphism<A_84>>;
};

// @public
export type FromEntries<T extends readonly [...(readonly [PropertyKey, any][])]> = Flatten<IntersectUnion<EntryToRecord<T[number]>>>;

// @public (undocumented)
export type FromKeys<K extends string> = <R>(f: (k: K) => R) => Record<K, R>;

// @public (undocumented)
export const fromKeys: <T extends readonly any[]>(keys: T) => FromKeys<T[number]>;

// @public (undocumented)
export type FunctionN<A extends unknown[], B> = function.FunctionN<A, B>;

// @public (undocumented)
export const geq: PRE.Predicate<Pair<number>>;

// @public (undocumented)
export const halfInt: Unary<number, Pair<number>>;

// @public (undocumented)
export type HasKey<K extends PropertyKey, V> = HasTotalKey<K, V>;

// @public (undocumented)
export type HasKeyEndo<K extends PropertyKey, V> = Endo<HasKey<K, V>>;

// @public (undocumented)
export type HasTotalKey<K extends PropertyKey, V> = {
    [k in K]: V;
};

// @public (undocumented)
export type Head<T extends AnyTuple> = T[0];

// @public (undocumented)
export const head: <T>(arr: T[]) => T;

// @public (undocumented)
export const headTail: <T>(arr: T[]) => [T, T[]];

export { HKT }

// @public
export const indexRecord: <A extends string>(xs: readonly A[]) => Record<A, number>;

// @public (undocumented)
export const init: <T>(arr: T[]) => T[];

// @public (undocumented)
export const initLast: <T>(arr: T[]) => [T[], T];

// @public (undocumented)
export type IntersectUnion<T> = (T extends T ? Effect<T> : never) extends (p: infer U) => void ? U : never;

// @public (undocumented)
export type KeyList<T> = U.ListOf<keyof T>;

// @public (undocumented)
export type Last<T extends AnyTuple> = T extends readonly [
...DropLast<T>,
infer L
] ? L : [];

// @public (undocumented)
export const last: <T>(arr: T[]) => T;

// @public (undocumented)
export type Lazy<A> = function.Lazy<A>;

// @public (undocumented)
export type LensResult<L extends lens.Lens<any, any>> = ReturnType<L['get']>;

// @public (undocumented)
export const leq: PRE.Predicate<Pair<number>>;

// @public (undocumented)
export const lines: Unary<string, string[]>;

// @public (undocumented)
export const mapEntriesOf: <T extends {}>() => <R>(f: (o: ObjectEntry<T>) => R) => (t: T) => readonly R[];

// @public (undocumented)
export type Mapper<F extends HKT.URIS> = <A, B>(f: Unary<A, B>) => Unary<HKT.Kind<F, A>, HKT.Kind<F, B>>;

// @public (undocumented)
export type Mapper2D<A, B> = ([rowIdx, colIdx]: [number, number], a: A) => B;

// @public (undocumented)
export const mapRange: <R>(f: Unary<number, R>) => Unary<Pair<number>, R[]>;

// @public (undocumented)
export const mapValues: <A, B>(f: (a: A) => B) => <K extends PropertyKey>(o: Record<K, A>) => Record<K, B>;

// @public (undocumented)
export const mapValuesOf: <K extends PropertyKey, V>() => <R>(f: (v: V) => R) => (o: Record<K, V>) => Record<K, R>;

// @public (undocumented)
export const mapWithIndex2: <A, B>(f: Mapper2D<A, B>) => Unary<A[][], B[][]>;

// @public (undocumented)
export const max: Unary<number[], number>;

// @public (undocumented)
export const maxPositiveMonoid: MO.Monoid<number>;

// @public (undocumented)
export const measureText: Unary<string[], Record<'width' | 'height', number>>;

// @public
export const membershipTest: <A extends string>(xs: readonly A[]) => (k: string) => boolean;

// @public (undocumented)
export const min: Unary<number[], number>;

export { MO }

// @public
export interface ModLens<T, R> extends lens.Lens<T, R> {
    // (undocumented)
    mod: Unary<Endo<R>, Endo<T>>;
}

// @public (undocumented)
export const modLens: <T, R>(src: lens.Lens<T, R>) => ModLens<T, R>;

// @public (undocumented)
export const monoidMax: MO.Monoid<number>;

// @public (undocumented)
export const monoidMin: MO.Monoid<number>;

// @public (undocumented)
export const monoObject: <V>(v: V) => <K extends string>(keys: readonly K[]) => Record<K, V>;

// @public (undocumented)
export const nChars: BinaryC<string, number, string>;

export { NEA }

// @public (undocumented)
export const neMapWithIndex2: <A, B>(f: Mapper2D<A, B>) => Unary<NEA.NonEmptyArray<NEA.NonEmptyArray<A>>, NEA.NonEmptyArray<NEA.NonEmptyArray<B>>>;

// @public (undocumented)
export const nonEmptyAppend: <T>(second: T[]) => Endo<NEA.NonEmptyArray<T>>;

// @public (undocumented)
export type NonEmptyArray<A> = NEA.NonEmptyArray<A>;

// @public (undocumented)
export const nonEmptyPrepend: <T>(first: T[]) => Endo<NEA.NonEmptyArray<T>>;

// @public (undocumented)
export const nSpaces: Unary<number, string>;

// @public (undocumented)
export const NU: {
    isValid: PRE.Predicate<number>;
    fromStringWithRadix: (radix: number) => (string: string) => OP.Option<number>;
    fromString: (string: string) => OP.Option<number>;
    floatFromString: (x: string) => OP.Option<number>;
    increment: EO.Endomorphism<number>;
    decrement: EO.Endomorphism<number>;
    add: (x: number) => EO.Endomorphism<number>;
    multiply: (x: number) => EO.Endomorphism<number>;
    subtract: (subtrahend: number) => EO.Endomorphism<number>;
    divide: (divisor: number) => EO.Endomorphism<number>;
    rem: (divisor: number) => EO.Endomorphism<number>;
    mod: (divisor: number) => EO.Endomorphism<number>;
    negate: EO.Endomorphism<number>;
    isFinite: PRE.Predicate<number>;
    toFinite: EO.Endomorphism<number>;
    isPositive: PRE.Predicate<number>;
    isNegative: PRE.Predicate<number>;
    isNonNegative: PRE.Predicate<number>;
    isNonPositive: PRE.Predicate<number>;
    isNumber: Refinement<unknown, number>;
    Eq: EQ.Eq<number>;
    Ord: OD.Ord<number>;
    Bounded: Bounded<number>;
    Show: SH.Show<number>;
    MagmaSub: Magma<number>;
    SemigroupSum: Semigroup<number>;
    SemigroupProduct: Semigroup<number>;
    MonoidSum: MO.Monoid<number>;
    MonoidProduct: MO.Monoid<number>;
    Field: Field<number>;
};

// @public
export type ObjectEntries<T> = U.ListOf<ObjectEntry<T>>;

// @public
export type ObjectEntry<T> = {
    [K in keyof T]: [K, T[K]];
}[keyof T];

// @public (undocumented)
export const objectMono: <K extends string>(keys: readonly K[]) => <V>(v: V) => Record<K, V>;

export { OD }

export { OP }

// @public (undocumented)
export type OrdEntry<T> = ObjectEntry<OrdStruct<T>>;

// @public (undocumented)
export type OrdStruct<T> = {
    [K in keyof T]: OD.Ord<T[K]>;
};

// @public
export const ordStruct: <T>(ord: MO.Monoid<OD.Ord<T>>) => Unary<OrdStruct<T>, OD.Ord<T>>;

// @public (undocumented)
export const pad: (total: number, align: 'left' | 'center' | 'right', padding?: string) => (s: string) => string;

// @public (undocumented)
export type Pair<T> = [T, T];

// @public (undocumented)
export const pairAp: <A, B, C>(f: Unary<A, B>, g: Unary<A, C>) => Unary<[A, A], [B, C, B, C]>;

// @public (undocumented)
export const pairApply: <A, B>([a, f]: [A, Unary<A, B>]) => B;

// @public (undocumented)
export const pairCartesian: <A, B, C, D>([[a, b], [c, d]]: readonly [readonly [A, B], readonly [C, D]]) => [[A, C], [B, C], [A, D], [B, D]];

// @public (undocumented)
export const pairFlow: <A, B, C>([f, g]: [Unary<A, B>, Unary<B, C>]) => Unary<A, C>;

// @public
export const pairLens: <T, A, B>([fst, snd]: [lens.Lens<T, A>, lens.Lens<T, B>]) => lens.Lens<T, [A, B]>;

// @public (undocumented)
export type PartialUnary<Q, R> = (q?: Q) => R;

// @public
export const picks: <KS extends readonly PropertyKey[]>(...keys: KS) => <T extends { [K in KS[number]]?: T[K]; }>(o: T) => Pick<T, KS[number]>;

// @public
export const picksT: <KS extends readonly PropertyKey[]>(keys: KS) => <T extends { [K in [...KS][number]]?: T[K]; }>(o: T) => Pick<T, [...KS][number]>;

// @public (undocumented)
export const pluck: <K extends string>(k: K) => <T extends HasKey<K, T[K]>>(o: T) => T[K];

// @public
export const pluckF: <T extends {}>(o: T) => <K extends string & keyof T>(k: K) => T[K];

// @public (undocumented)
export const pluckFrom: <K extends string>(k: K) => <T extends HasKey<K, T[K]>>() => (t: T) => T[K];

export { PRE }

export { RA }

export { RC }

export { RE }

// @public
export const repeatSubgrid: ([width, height]: Pair<number>) => <T>(from: T[][]) => T[][];

// @public
export type Reverse<T extends AnyTuple> = T['length'] extends 0 ? [] : T['length'] extends 1 ? T : [...Reverse<Tail<T>>, Head<T>];

// @public (undocumented)
export const self: <A, R>(f: YM<A, R>) => Unary<A, R>;

// @public (undocumented)
export const selfMap: <T extends readonly any[]>(keys: T) => { [K in T[number]]: K; };

// @public (undocumented)
export const setProp: SetValue;

// @public (undocumented)
export const setPropOf: <T extends {}>() => <K extends keyof T>(k: K) => SetterOf<T, K>;

// @public (undocumented)
export type SetterOf<T extends {}, K extends keyof T> = (t: T[K]) => Endo<T>;

// @public (undocumented)
export type SetValue = <K extends PropertyKey>(k: K) => <V>(v: V) => HasKeyEndo<K, V>;

export { SH }

// @public (undocumented)
export const split: (re: RegExp) => Unary<string, string[]>;

// @public (undocumented)
export const splitAt: (n: number) => <T>(xs: T[]) => [T[], T, T[]];

// @public (undocumented)
export const STR: {
    fromNumber: (x: number) => string;
    prepend: (prepended: string) => EO.Endomorphism<string>;
    unprepend: (start: string) => EO.Endomorphism<string>;
    append: (appended: string) => EO.Endomorphism<string>;
    unappend: (end: string) => EO.Endomorphism<string>;
    surround: (x: string) => EO.Endomorphism<string>;
    unsurround: (x: string) => EO.Endomorphism<string>;
    takeLeft: (n: number) => EO.Endomorphism<string>;
    takeRight: (n: number) => EO.Endomorphism<string>;
    match: (r: RegExp) => (x: string) => OP.Option<RegExpMatchArray>;
    matchAll: (r: RegExp) => (x: string) => OP.Option<NEA.NonEmptyArray<RegExpMatchArray>>;
    under: (f: EO.Endomorphism<readonly string[]>) => EO.Endomorphism<string>;
    reverse: EO.Endomorphism<string>;
    lines: (s: string) => ReadonlyNonEmptyArray<string>;
    unlines: (ys: readonly string[]) => string;
    test: (r: RegExp) => PRE.Predicate<string>;
    replaceAll: (r: string) => (s: string) => EO.Endomorphism<string>;
    dropLeft: (n: number) => EO.Endomorphism<string>;
    dropRight: (n: number) => EO.Endomorphism<string>;
    dropLeftWhile: (f: PRE.Predicate<string>) => EO.Endomorphism<string>;
    dropRightWhile: (f: PRE.Predicate<string>) => EO.Endomorphism<string>;
    head: (x: string) => OP.Option<string>;
    tail: (x: string) => OP.Option<string>;
    last: (x: string) => OP.Option<string>;
    init: (x: string) => OP.Option<string>;
    lookup: (i: number) => (x: string) => OP.Option<string>;
    takeLeftWhile: (f: PRE.Predicate<string>) => EO.Endomorphism<string>;
    takeRightWhile: (f: PRE.Predicate<string>) => EO.Endomorphism<string>;
    splitAt: (index: number) => (str: string) => [string, string];
    isAlpha: PRE.Predicate<string>;
    isAlphaNum: PRE.Predicate<string>;
    isLower: PRE.Predicate<string>;
    isUpper: PRE.Predicate<string>;
    isSpace: PRE.Predicate<string>;
    words: (s: string) => ReadonlyNonEmptyArray<string>;
    unwords: (ys: readonly string[]) => string;
    Eq: EQ.Eq<string>;
    Semigroup: Semigroup<string>;
    empty: "";
    Monoid: MO.Monoid<string>;
    Ord: OD.Ord<string>;
    Show: SH.Show<string>;
    isString: Refinement<unknown, string>;
    toUpperCase: (s: string) => string;
    toLowerCase: (s: string) => string;
    replace: (searchValue: string | RegExp, replaceValue: string) => (s: string) => string;
    trim: (s: string) => string;
    trimLeft: (s: string) => string;
    trimRight: (s: string) => string;
    slice: (start: number, end: number) => (s: string) => string;
    isEmpty: (s: string) => boolean;
    size: (s: string) => number;
    split: (separator: string | RegExp) => (s: string) => ReadonlyNonEmptyArray<string>;
    includes: (searchString: string, position?: number | undefined) => (s: string) => boolean;
    startsWith: (searchString: string, position?: number | undefined) => (s: string) => boolean;
    endsWith: (searchString: string, position?: number | undefined) => (s: string) => boolean;
};

// @public (undocumented)
export const stringEq: Unary<string, PRE.Predicate<string>>;

// @public (undocumented)
export type Tail<T extends AnyTuple> = T extends readonly [any?, ...infer U] ? U : [...T];

// @public (undocumented)
export const tail: <T>(arr: T[]) => T[];

// @public (undocumented)
export type Tailcall<T> = Unary<T, Trampoline<T>>;

// @public (undocumented)
export type Ternary<S, P, Q, R> = FunctionN<[S, P, Q], R>;

// @public (undocumented)
export type TernaryC<S, P, Q, R> = Unary<S, Unary<P, Unary<Q, R>>>;

// @public (undocumented)
export type Thunk<T> = Lazy<Trampoline<T>>;

// @public (undocumented)
export const toTrueRecord: <K extends string>(ks: readonly K[]) => IntersectUnion<Record<K, boolean>> extends infer T ? { [P in keyof T]: IntersectUnion<Record<K, boolean>>[P]; } : never;

// @public (undocumented)
export interface Trampoline<T> {
    // (undocumented)
    _tag: typeof _tag;
    // (undocumented)
    wrapped: Wrapped<T>;
}

// @public
export const trampoline: <T>(res0: Trampoline<T>) => T;

// @public (undocumented)
export const TU: {
    traverseToFst<F extends "StateReaderTaskEither">(F: Functor4<F>): <S, R, E, A, B>(g: (x: A) => HKT.Kind4<F, S, R, E, B>) => (x: A) => HKT.Kind4<F, S, R, E, [B, A]>;
    traverseToFst<F_1 extends keyof HKT.URItoKind3<any, any, any>>(F: Functor3<F_1>): <R_1, E_1, A_1, B_1>(g: (x: A_1) => HKT.Kind3<F_1, R_1, E_1, B_1>) => (x: A_1) => HKT.Kind3<F_1, R_1, E_1, [B_1, A_1]>;
    traverseToFst<F_2 extends keyof HKT.URItoKind2<any, any>>(F: Functor2<F_2>): <E_2, A_2, B_2>(g: (x: A_2) => HKT.Kind2<F_2, E_2, B_2>) => (x: A_2) => HKT.Kind2<F_2, E_2, [B_2, A_2]>;
    traverseToFst<F_3 extends keyof HKT.URItoKind2<any, any>, E_3>(F: Functor2C<F_3, E_3>): <A_3, B_3>(g: (x: A_3) => HKT.Kind2<F_3, E_3, B_3>) => (x: A_3) => HKT.Kind2<F_3, E_3, [B_3, A_3]>;
    traverseToFst<F_4 extends keyof HKT.URItoKind<any>>(F: Functor1<F_4>): <A_4, B_4>(g: (x: A_4) => HKT.Kind<F_4, B_4>) => (x: A_4) => HKT.Kind<F_4, [B_4, A_4]>;
    traverseToFst<F_5>(F: Functor<F_5>): <A_5, B_5>(g: (x: A_5) => HKT.HKT<F_5, B_5>) => (x: A_5) => HKT.HKT<F_5, [B_5, A_5]>;
    traverseToSnd<F_6 extends "StateReaderTaskEither">(F: Functor4<F_6>): <S_1, R_2, E_4, A_6, B_6>(g: (x: A_6) => HKT.Kind4<F_6, S_1, R_2, E_4, B_6>) => (x: A_6) => HKT.Kind4<F_6, S_1, R_2, E_4, [A_6, B_6]>;
    traverseToSnd<F_7 extends keyof HKT.URItoKind3<any, any, any>>(F: Functor3<F_7>): <R_3, E_5, A_7, B_7>(g: (x: A_7) => HKT.Kind3<F_7, R_3, E_5, B_7>) => (x: A_7) => HKT.Kind3<F_7, R_3, E_5, [A_7, B_7]>;
    traverseToSnd<F_8 extends keyof HKT.URItoKind2<any, any>>(F: Functor2<F_8>): <E_6, A_8, B_8>(g: (x: A_8) => HKT.Kind2<F_8, E_6, B_8>) => (x: A_8) => HKT.Kind2<F_8, E_6, [A_8, B_8]>;
    traverseToSnd<F_9 extends keyof HKT.URItoKind2<any, any>, E_7>(F: Functor2C<F_9, E_7>): <A_9, B_9>(g: (x: A_9) => HKT.Kind2<F_9, E_7, B_9>) => (x: A_9) => HKT.Kind2<F_9, E_7, [A_9, B_9]>;
    traverseToSnd<F_10 extends keyof HKT.URItoKind<any>>(F: Functor1<F_10>): <A_10, B_10>(g: (x: A_10) => HKT.Kind<F_10, B_10>) => (x: A_10) => HKT.Kind<F_10, [A_10, B_10]>;
    traverseToSnd<F_11>(F: Functor<F_11>): <A_11, B_11>(g: (x: A_11) => HKT.HKT<F_11, B_11>) => (x: A_11) => HKT.HKT<F_11, [A_11, B_11]>;
    dup: <A_12>(x: A_12) => [A_12, A_12];
    toFst: <A_13, B_12>(f: (x: A_13) => B_12) => (x: A_13) => [B_12, A_13];
    toSnd: <A_14, B_13>(f: (x: A_14) => B_13) => (x: A_14) => [A_14, B_13];
    withFst: <A_15>(x: A_15) => <B_14>(y: B_14) => [A_15, B_14];
    withSnd: <A_16>(x: A_16) => <B_15>(y: B_15) => [B_15, A_16];
    create: <A_17, B_16>(xs: [A_17, B_16]) => [A_17, B_16];
    mapBoth: <A_18, B_17>(f: (x: A_18) => B_17) => (xs: [A_18, A_18]) => [B_17, B_17];
    fanout: <A_19, B_18>(f: (x: A_19) => B_18) => <C>(g: (x: A_19) => C) => (x: A_19) => [B_18, C];
    getApply<S_2>(S: Semigroup<S_2>): Apply2C<"Tuple", S_2>;
    getApplicative<M>(M: MO.Monoid<M>): AP.Applicative2C<"Tuple", M>;
    getChain<S_3>(S: Semigroup<S_3>): Chain2C<"Tuple", S_3>;
    getMonad<M_1>(M: MO.Monoid<M_1>): Monad2C<"Tuple", M_1>;
    getChainRec<M_2>(M: MO.Monoid<M_2>): ChainRec2C<"Tuple", M_2>;
    fst: <A_20, E_8>(ea: [A_20, E_8]) => A_20;
    snd: <A_21, E_9>(ea: [A_21, E_9]) => E_9;
    swap: <A_22, E_10>(ea: [A_22, E_10]) => [E_10, A_22];
    bimap: <E_11, G, A_23, B_19>(mapSnd: (e: E_11) => G, mapFst: (a: A_23) => B_19) => (fa: [A_23, E_11]) => [B_19, G];
    mapFst: <A_24, B_20>(f: (a: A_24) => B_20) => <E_12>(fa: [A_24, E_12]) => [B_20, E_12];
    mapSnd: <E_13, G_1>(f: (e: E_13) => G_1) => <A_25>(fa: [A_25, E_13]) => [A_25, G_1];
    compose: <A_26, B_21>(ab: [B_21, A_26]) => <C_1>(bc: [C_1, B_21]) => [C_1, A_26];
    extend: <E_14, A_27, B_22>(f: (wa: [A_27, E_14]) => B_22) => (wa: [A_27, E_14]) => [B_22, E_14];
    duplicate: <E_15, A_28>(wa: [A_28, E_15]) => [[A_28, E_15], E_15];
    extract: <E_16, A_29>(wa: [A_29, E_16]) => A_29;
    foldMap: <M_3>(M: MO.Monoid<M_3>) => <A_30>(f: (a: A_30) => M_3) => <E_17>(fa: [A_30, E_17]) => M_3;
    reduce: <A_31, B_23>(b: B_23, f: (b: B_23, a: A_31) => B_23) => <E_18>(fa: [A_31, E_18]) => B_23;
    reduceRight: <A_32, B_24>(b: B_24, f: (a: A_32, b: B_24) => B_24) => <E_19>(fa: [A_32, E_19]) => B_24;
    traverse: PipeableTraverse2<"Tuple">;
    sequence: Sequence2<"Tuple">;
    URI: "Tuple";
    Functor: Functor2<"Tuple">;
    flap: <A_33>(a: A_33) => <E_20, B_25>(fab: [(a: A_33) => B_25, E_20]) => [B_25, E_20];
    Bifunctor: BI.Bifunctor2<"Tuple">;
    Semigroupoid: Semigroupoid2<"Tuple">;
    Comonad: Comonad2<"Tuple">;
    Foldable: Foldable2<"Tuple">;
    Traversable: Traversable2<"Tuple">;
    map: <A_34, B_26>(f: (a: A_34) => B_26) => <E_21>(fa: [A_34, E_21]) => [B_26, E_21];
    mapLeft: <E_22, G_2>(f: (e: E_22) => G_2) => <A_35>(fa: [A_35, E_22]) => [A_35, G_2];
    tuple: Semigroupoid2<"Tuple"> & BI.Bifunctor2<"Tuple"> & Comonad2<"Tuple"> & Foldable2<"Tuple"> & Traversable2<"Tuple">;
};

// @public (undocumented)
export type Tuple3<T> = [T, T, T];

// @public (undocumented)
export const tuple3Map: <T, U>(f: Unary<T, U>) => Unary<Tuple3<T>, Tuple3<U>>;

// @public (undocumented)
export type Tuple4<T> = [T, T, T, T];

// @public (undocumented)
export const tuple4Map: <T, U>(f: Unary<T, U>) => Unary<Tuple4<T>, Tuple4<U>>;

// @public (undocumented)
export const tupleAppend: <A>(a: A) => <T extends readonly any[]>(tuple: T) => readonly [...T, A];

// @public (undocumented)
export type TupleN<T, Len extends number> = readonly [T, ...T[]] & {
    length: Len;
};

// @public (undocumented)
export const typedEntries: <T extends {}>(o: T) => ListOf<ObjectEntry<T>>;

// @public (undocumented)
export const typedFromEntries: <T extends readonly [PropertyKey, any][]>(entries: T) => IntersectUnion<EntryToRecord<T[number]>> extends infer T_1 ? { [P in keyof T_1]: IntersectUnion<EntryToRecord<T[number]>>[P]; } : never;

// @public (undocumented)
export const typedKeys: <T extends {}>(o: T) => ListOf<keyof T>;

// @public (undocumented)
export const typedValues: <T extends {}>(o: T) => ValueList<T, ListOf<keyof T>>;

// @public (undocumented)
export const ucFirst: Endo<string>;

// @public (undocumented)
export type Unary<Q, R> = function.FunctionN<[Q], R>;

// @public
export type Unary1<F extends HKT.URIS, R> = <A>(fa: HKT.Kind<F, A>) => R;

// @public (undocumented)
export type UnaryRest<Q, R> = (...args: Q[]) => R;

// @public
export type uncurry2T = <A, B, C>(f: BinaryC<A, B, C>) => Binary<A, B, C>;

// @public (undocumented)
export const uncurry2T: uncurry2T;

// @public
export type ValueList<T, KS extends KeyList<T> = KeyList<T>> = KS['length'] extends 0 ? [] : [T[KS[0]], ...ValueList<Omit<T, KS[0]>, KeyList<Omit<T, KS[0]>>>];

// @public (undocumented)
export const widestLine: Unary<string[], number>;

// @public (undocumented)
export const withAdjacent: <T>(chain: T[]) => AdjEntry<T>[];

// @public (undocumented)
export type WithKeys<K1 extends string, K2 extends string, A, B> = {
    [k in K1]: A;
} & {
    [k in K2]: B;
};

// @public (undocumented)
export const withKeys: <K1 extends string, K2 extends string>(k1: K1, k2: K2) => <A, B>([a, b]: [A, B]) => WithKeys<K1, K2, A, B>;

// @public (undocumented)
export type Wrapped<T> = EI.Either<Thunk<T>, T>;

// @public (undocumented)
export type Y = <A, R>(f: YF<A, R>) => Unary<A, R>;

// @public
export const Y: Y;

// @public (undocumented)
export type YF<A, R> = Endo<Unary<A, R>>;

// @public (undocumented)
export type YM<A, R> = (f: YM<A, R>) => Unary<A, R>;

// @public (undocumented)
export const zipU: <A, B>(bs: B[], as: A[]) => [A, B][];

// (No @packageDocumentation comment for this package)

```
